<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stateful processors &mdash; Streamiz.Kafka.Net  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="State stores" href="stores.html" />
    <link rel="prev" title="Stateless processors" href="stateless-processors.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Streamiz.Kafka.Net
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Streamiz.Kafka.Net</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="stream-configuration.html">Configuring a Stream Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="threading-model.html">Threading model</a></li>
<li class="toctree-l1"><a class="reference internal" href="stateless-processors.html">Stateless processors</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Stateful processors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#count">Count</a></li>
<li class="toctree-l2"><a class="reference internal" href="#count-windowed">Count (Windowed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aggregate">Aggregate</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aggregate-windowed">Aggregate (Windowed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduce">Reduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduce-windowed">Reduce (Windowed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ikstream-ikstream-join">IKStream-IKStream Join</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inner-join-windowed">Inner Join (Windowed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#left-join-windowed">Left Join (Windowed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#outer-join-windowed">Outer Join (Windowed)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ikstream-iktable-join">IKStream-IKTable Join</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inner-join">Inner Join</a></li>
<li class="toctree-l3"><a class="reference internal" href="#left-join">Left Join</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ikstream-iglobalktable-join">IKStream-IGlobalKTable Join</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Inner Join</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Left Join</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#iktable-iktable-equi-join">IKTable-IKTable Equi-Join</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">Inner Join</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Left Join</a></li>
<li class="toctree-l3"><a class="reference internal" href="#outer-join">Outer Join</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="stores.html">State stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="topology-test-driver.html">Test topology driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="monitoring.html">Monitoring Stream Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="async-processing.html">Asynchronous processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="processor-api.html">Processor API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Streamiz.Kafka.Net</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Stateful processors</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/stateful-processors.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="stateful-processors">
<h1>Stateful processors<a class="headerlink" href="#stateful-processors" title="Permalink to this heading">¶</a></h1>
<p>Stateful transformations depend on state for processing inputs and producing outputs and require a state store associated with the stream processor. For example, in aggregating operations, a windowing state store is used to collect the latest aggregation results per window. In join operations, a windowing state store is used to collect all of the records received so far within the defined window boundary.</p>
<section id="count">
<h2>Count<a class="headerlink" href="#count" title="Permalink to this heading">¶</a></h2>
<p><strong>Rolling aggregation.</strong> Counts the number of records by the grouped key. (see IKGroupedStream for details)</p>
<p>Several variants of count exist.</p>
<ul class="simple">
<li><p>IKGroupedStream  → IKTable</p></li>
<li><p>IKGroupedTable  -&gt; IKTable</p></li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">());</span>

<span class="c1">// Counting a IKGroupedStream</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span><span class="p">.</span><span class="n">Count</span><span class="p">(</span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;count-store&quot;</span><span class="p">));</span>

<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                </span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">KeyValuePair</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">ToCharArray</span><span class="p">()[</span><span class="m">0</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">                </span><span class="p">.</span><span class="n">Count</span><span class="p">(</span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;count-store2&quot;</span><span class="p">).</span><span class="n">WithKeySerdes</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">CharSerDes</span><span class="p">()));</span>
</pre></div>
</div>
<p>Detailed behavior for IKGroupedStream:</p>
<ul class="simple">
<li><p>Input records with null keys or values are ignored.</p></li>
</ul>
<p>Detailed behavior for IKGroupedTable:</p>
<ul class="simple">
<li><p>Input records with null keys are ignored. Records with null values are not ignored but interpreted as “tombstones” for the corresponding key, which indicate the deletion of the key from the table.</p></li>
</ul>
</section>
<section id="count-windowed">
<h2>Count (Windowed)<a class="headerlink" href="#count-windowed" title="Permalink to this heading">¶</a></h2>
<p>** Windowed aggregation.** Counts the number of records, per window, by the grouped key. (ITimeWindowedKStream details)</p>
<p>The windowed count turns a ITimeWindowedKStream&lt;K, V&gt; into a windowed IKTable&lt;Windowed<K>, V&gt;.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupByKey</span><span class="p">();</span>

<span class="kt">var</span><span class="w"> </span><span class="n">countStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span>
<span class="w">                    </span><span class="p">.</span><span class="n">WindowedBy</span><span class="p">(</span><span class="n">TumblingWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="m">2000</span><span class="p">))</span>
<span class="w">                    </span><span class="p">.</span><span class="n">Count</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>Input records with null keys or values are ignored.</p></li>
</ul>
</section>
<section id="aggregate">
<h2>Aggregate<a class="headerlink" href="#aggregate" title="Permalink to this heading">¶</a></h2>
<p><strong>Rolling aggregation.</strong> Aggregates the values of (non-windowed) records by the grouped key. Aggregating is a generalization of reduce and allows, for example, the aggregate value to have a different type than the input values. (see IKGroupedStream for details)</p>
<p>When aggregating a grouped stream, you must provide an initializer (e.g., aggValue = 0) and an “adder” aggregator (e.g., aggValue + curValue).</p>
<p>Several variants of aggregate exist.</p>
<ul class="simple">
<li><p>KGroupedStream → IKTable</p></li>
<li><p>IKGroupedTable  -&gt; IKTable</p></li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">());</span>

<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span><span class="p">.</span><span class="n">Aggregate</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="m">0L</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">agg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">agg</span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;agg-store&quot;</span><span class="p">).</span><span class="n">WithValueSerdes</span><span class="o">&lt;</span><span class="n">Int64SerDes</span><span class="o">&gt;</span><span class="p">());</span>

<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                </span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">KeyValuePair</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">                </span><span class="p">.</span><span class="n">Aggregate</span><span class="p">(</span>
<span class="w">                    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span>
<span class="w">                    </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="kt">var</span><span class="w"> </span><span class="n">caracs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">ToCharArray</span><span class="p">();</span>
<span class="w">                        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">caracs</span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="w">                                </span><span class="o">++</span><span class="n">old</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
<span class="w">                            </span><span class="k">else</span>
<span class="w">                                </span><span class="n">old</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="w">                    </span><span class="p">},</span>
<span class="w">                    </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">old</span><span class="p">,</span>
<span class="w">                    </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;agg-store2&quot;</span><span class="p">).</span><span class="n">WithValueSerdes</span><span class="o">&lt;</span><span class="n">DictionarySerDes</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">                </span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior of IKGroupedStream:</p>
<ul class="simple">
<li><p>Input records with null keys are ignored.</p></li>
<li><p>When a record key is received for the first time, the initializer is called (and called before the adder).</p></li>
<li><p>Whenever a record with a non-null value is received, the adder is called.</p></li>
</ul>
<p>Detailed behavior of IKGroupedTable:</p>
<ul class="simple">
<li><p>Input records with null keys are ignored.</p></li>
<li><p>When a record key is received for the first time, the initializer is called (and called before the adder and subtractor). Note that, in contrast to IKGroupedStream, over time the initializer may be called more than once for a key as a result of having received input tombstone records for that key (see below).</p></li>
<li><p>When the first non-null value is received for a key (e.g., INSERT), then only the adder is called.</p></li>
<li><p>When subsequent non-null values are received for a key (e.g., UPDATE), then (1) the subtractor is called with the old value as stored in the table and (2) the adder is called with the new value of the input record that was just received. The order of execution for the subtractor and adder is not defined.</p></li>
<li><p>When a tombstone record – i.e. a record with a null value – is received for a key (e.g., DELETE), then only the subtractor is called. Note that, whenever the subtractor returns a null value itself, then the corresponding key is removed from the resulting IKTable. If that happens, any next input record for that key will trigger the initializer again.</p></li>
</ul>
</section>
<section id="aggregate-windowed">
<h2>Aggregate (Windowed)<a class="headerlink" href="#aggregate-windowed" title="Permalink to this heading">¶</a></h2>
<p><strong>Windowed aggregation.</strong> Aggregates the values of records, per window, by the grouped key. Aggregating is a generalization of reduce and allows, for example, the aggregate value to have a different type than the input values. (ITimeWindowedKStream details)</p>
<p>You must provide an initializer (e.g., aggValue = 0), “adder” aggregator (e.g., aggValue + curValue), and a window. When windowing based on sessions, you must additionally provide a “session merger” aggregator (e.g., mergedAggValue = leftAggValue + rightAggValue).</p>
<p>The windowed aggregate turns a ITimeWindowedKStream&lt;K, V&gt; into a windowed IKTable&lt;Windowed<K>, V&gt;.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupByKey</span><span class="p">();</span>

<span class="kt">var</span><span class="w"> </span><span class="n">aggStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span>
<span class="w">                    </span><span class="p">.</span><span class="n">WindowedBy</span><span class="p">(</span><span class="n">TumblingWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="m">2000</span><span class="p">))</span>
<span class="w">                    </span><span class="p">.</span><span class="n">Aggregate</span><span class="p">(</span>
<span class="w">                        </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">,</span>
<span class="w">                        </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">agg</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">agg</span><span class="p">),</span>
<span class="w">                        </span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The windowed aggregate behaves similar to the rolling aggregate described above. The additional twist is that the behavior applies per window.</p></li>
<li><p>Input records with null keys are ignored in general.</p></li>
<li><p>When a record key is received for the first time for a given window, the initializer is called (and called before the adder).</p></li>
<li><p>Whenever a record with a non-null value is received for a given window, the adder is called.</p></li>
</ul>
</section>
<section id="reduce">
<h2>Reduce<a class="headerlink" href="#reduce" title="Permalink to this heading">¶</a></h2>
<p><strong>Rolling aggregation.</strong> Combines the values of (non-windowed) records by the grouped key. The current record value is combined with the last reduced value, and a new reduced value is returned. The result value type cannot be changed, unlike aggregate. (see IKGroupedStream for details)</p>
<p>When reducing a grouped stream, you must provide an “adder” reducer (e.g., aggValue + curValue).</p>
<p>Several variants of reduce exist.</p>
<ul class="simple">
<li><p>IKGroupedStream  → IKTable</p></li>
<li><p>IKGroupedTable  -&gt; IKTable</p></li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">MapValues</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">());</span>

<span class="c1">// Reduce a IKGroupedStream</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span><span class="p">.</span><span class="n">Reduce</span><span class="p">((</span><span class="n">agg</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">agg</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">new</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;reduce-store&quot;</span><span class="p">).</span><span class="n">WithValueSerdes</span><span class="o">&lt;</span><span class="n">Int32SerDes</span><span class="o">&gt;</span><span class="p">());</span>

<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                </span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                </span><span class="p">.</span><span class="n">MapValues</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
<span class="w">                </span><span class="p">.</span><span class="n">GroupBy</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">KeyValuePair</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
<span class="w">                </span><span class="p">.</span><span class="n">Reduce</span><span class="p">(</span>
<span class="w">                    </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">),</span>
<span class="w">                    </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">),</span>
<span class="w">                    </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;reduce-store2&quot;</span><span class="p">).</span><span class="n">WithValueSerdes</span><span class="o">&lt;</span><span class="n">Int32SerDes</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p>Detailed behavior for IKGroupedStream:</p>
<ul class="simple">
<li><p>Input records with null keys are ignored in general.</p></li>
<li><p>When a record key is received for the first time, then the value of that record is used as the initial aggregate value.</p></li>
<li><p>Whenever a record with a non-null value is received, the adder is called.</p></li>
</ul>
<p>Detailed behavior for IKGroupedTable:</p>
<ul class="simple">
<li><p>Input records with null keys are ignored in general.</p></li>
<li><p>When a record key is received for the first time, then the value of that record is used as the initial aggregate value. Note that, in contrast to IKGroupedStream, over time this initialization step may happen more than once for a key as a result of having received input tombstone records for that key (see below).</p></li>
<li><p>When the first non-null value is received for a key (e.g., INSERT), then only the adder is called.</p></li>
<li><p>When subsequent non-null values are received for a key (e.g., UPDATE), then (1) the subtractor is called with the old value as stored in the table and (2) the adder is called with the new value of the input record that was just received. The order of execution for the subtractor and adder is not defined.</p></li>
<li><p>When a tombstone record – i.e. a record with a null value – is received for a key (e.g., DELETE), then only the subtractor is called. Note that, whenever the subtractor returns a null value itself, then the corresponding key is removed from the resulting IKTable. If that happens, any next input record for that key will re-initialize its aggregate value.</p></li>
</ul>
</section>
<section id="reduce-windowed">
<h2>Reduce (Windowed)<a class="headerlink" href="#reduce-windowed" title="Permalink to this heading">¶</a></h2>
<p><strong>Windowed aggregation.</strong> Combines the values of records, per window, by the grouped key. The current record value is combined with the last reduced value, and a new reduced value is returned. Records with null key or value are ignored. The result value type cannot be changed, unlike aggregate. (ITimeWindowedKStream details)</p>
<p>The windowed reduce turns a turns a ITimeWindowedKStream&lt;K, V&gt; into a windowed IKTable&lt;Windowed<K>, V&gt;.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">groupedStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic&quot;</span><span class="p">)</span>
<span class="w">                        </span><span class="p">.</span><span class="n">GroupByKey</span><span class="p">();</span>

<span class="kt">var</span><span class="w"> </span><span class="n">reduceStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">groupedStream</span>
<span class="w">                        </span><span class="p">.</span><span class="n">WindowedBy</span><span class="p">(</span><span class="n">TumblingWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="m">2000</span><span class="p">))</span>
<span class="w">                        </span><span class="p">.</span><span class="n">Reduce</span><span class="p">((</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The windowed reduce behaves similar to the rolling reduce described above. The additional twist is that the behavior applies per window.</p></li>
<li><p>Input records with null keys are ignored in general.</p></li>
<li><p>When a record key is received for the first time for a given window, then the value of that record is used as the initial aggregate value.</p></li>
<li><p>Whenever a record with a non-null value is received for a given window, the reducer is called.</p></li>
</ul>
</section>
<section id="ikstream-ikstream-join">
<h2>IKStream-IKStream Join<a class="headerlink" href="#ikstream-ikstream-join" title="Permalink to this heading">¶</a></h2>
<p>IKStream-IKStream joins are always windowed joins, because otherwise the size of the internal state store used to perform the join – e.g., a sliding window or “buffer” – would grow indefinitely. For stream-stream joins it’s important to highlight that a new input record on one side will produce a join output for each matching record on the other side, and there can be multiple such matching records in a given join window.</p>
<section id="inner-join-windowed">
<h3>Inner Join (Windowed)<a class="headerlink" href="#inner-join-windowed" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IKStream) → IKStream</p></li>
</ul>
<p>Performs an INNER JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type IKStream&lt;K, V&gt; rather than IKStream&lt;Windowed<K>, V&gt;.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<p>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">);</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="n">JoinWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key, and window-based, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied JoinWindows, i.e. the window defines an additional join predicate over the record timestamps.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key or a null value are ignored and do not trigger the join. See the semantics overview at the bottom of this section for a detailed description.</p></li>
</ul>
</section>
<section id="left-join-windowed">
<h3>Left Join (Windowed)<a class="headerlink" href="#left-join-windowed" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IKStream) → IKStream</p></li>
</ul>
<p>Performs a LEFT JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type IKStream&lt;K, V&gt; rather than IKStream&lt;Windowed<K>, V&gt;.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<p>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">);</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">LeftJoin</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="n">JoinWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key, and window-based, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied JoinWindows, i.e. the window defines an additional join predicate over the record timestamps.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key or a null value are ignored and do not trigger the join. For each input record on the left side that does not have any match on the right side, the joiner will be called with joiner(leftRecord.value, null); this explains the row with timestamp=3 in the table below, which lists [A, null] in the LEFT JOIN column.</p></li>
</ul>
</section>
<section id="outer-join-windowed">
<h3>Outer Join (Windowed)<a class="headerlink" href="#outer-join-windowed" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IKStream) → IKStream</p></li>
</ul>
<p>Performs a OUTER JOIN of this stream with another stream. Even though this operation is windowed, the joined stream will be of type IKStream&lt;K, V&gt; rather than IKStream&lt;Windowed<K>, V&gt;.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<p>Causes data re-partitioning of a stream if and only if the stream was marked for re-partitioning (if both are marked, both are re-partitioned).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">stream2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">);</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">OuterJoin</span><span class="p">(</span><span class="n">stream2</span><span class="p">,</span><span class="w"> </span>
<span class="w">                    </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="n">JoinWindowOptions</span><span class="p">.</span><span class="n">Of</span><span class="p">(</span><span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMinutes</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key, and window-based, i.e. two input records are joined if and only if their timestamps are “close” to each other as defined by the user-supplied JoinWindows, i.e. the window defines an additional join predicate over the record timestamps.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key or a null value are ignored and do not trigger the join. For each input record on one side that does not have any match on the other side, the joiner will be called with joiner(leftRecord.value, null) or joiner(null, rightRecord.value), respectively; this explains the row with timestamp=3 in the table below, which lists [A, null] in the OUTER JOIN column (unlike LEFT JOIN, [null, x] is possible, too, but no such example is shown in the table).</p></li>
</ul>
</section>
</section>
<section id="ikstream-iktable-join">
<h2>IKStream-IKTable Join<a class="headerlink" href="#ikstream-iktable-join" title="Permalink to this heading">¶</a></h2>
<p>IKStream-IKTable joins are always non-windowed joins. They allow you to perform table lookups against a IKTable (changelog stream) upon receiving a new record from the IKStream (record stream). An example use case would be to enrich a stream of user activities (IKStream) with the latest user profile information (IKTable).</p>
<section id="inner-join">
<h3>Inner Join<a class="headerlink" href="#inner-join" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IKTable) → IKStream</p></li>
</ul>
<p>Performs an INNER JOIN of this stream with the table, effectively doing a table lookup.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<p>Causes data re-partitioning of the stream if and only if the stream was marked for re-partitioning.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table-store&quot;</span><span class="p">));</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">table</span><span class="p">,(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied joiner will be called to produce join output records.</p></li>
<li><p>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.
Input records for the stream with a null key or a null value are ignored and do not trigger the join.
Input records for the table with a null value are interpreted as tombstones for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join.</p></li>
</ul>
</section>
<section id="left-join">
<h3>Left Join<a class="headerlink" href="#left-join" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IKTable) → IKStream</p></li>
</ul>
<p>Performs an LEFT JOIN of this stream with the table, effectively doing a table lookup.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<p>Causes data re-partitioning of the stream if and only if the stream was marked for re-partitioning.b</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table-store&quot;</span><span class="p">));</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">LeftJoin</span><span class="p">(</span><span class="n">table</span><span class="p">,(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied joiner will be called to produce join output records.</p></li>
<li><p>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.
Input records for the stream with a null key or a null value are ignored and do not trigger the join.
Input records for the table with a null value are interpreted as tombstones for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join.
For each input record on the left side that does not have any match on the right side, the ValueJoiner will be called with joiner(leftRecord.value, null); this explains the row with timestamp=3 in the table below, which lists [A, null] in the LEFT JOIN column.</p></li>
</ul>
</section>
</section>
<section id="ikstream-iglobalktable-join">
<h2>IKStream-IGlobalKTable Join<a class="headerlink" href="#ikstream-iglobalktable-join" title="Permalink to this heading">¶</a></h2>
<p>IKStream-IGlobalKTable joins are always non-windowed joins. They allow you to perform table lookups against a IGlobalKTable (entire changelog stream) upon receiving a new record from the IKStream (record stream). An example use case would be “star queries” or “star joins”, where you would enrich a stream of user activities (IKStream) with the latest user profile information (IGlobalKTable) and further context information (further GlobalKTables). However, because GlobalKTables have no notion of time, a IKStream-IGlobalKTable join is not a temporal join, and there is no event-time synchronization between updates to a IGlobalKTable and processing of IKStream records.</p>
<p>At a high-level, IKStream-IGlobalKTable joins are very similar to IKStream-IKTable joins. However, global tables provide you with much more flexibility at the some expense when compared to partitioned tables:</p>
<ul class="simple">
<li><p>They do not require data co-partitioning.</p></li>
<li><p>They allow for efficient “star joins”; i.e., joining a large-scale “facts” stream against “dimension” tables</p></li>
<li><p>They allow for joining against foreign keys; i.e., you can lookup data in the table not just by the keys of records in the stream, but also by data in the record values.</p></li>
<li><p>They make many use cases feasible where you must work on heavily skewed data and thus suffer from hot partitions.</p></li>
<li><p>They are often more efficient than their partitioned IKTable counterpart when you need to perform multiple joins in succession.</p></li>
</ul>
<section id="id1">
<h3>Inner Join<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IGlobalKTable) → IKStream</p></li>
</ul>
<p>Performs an INNER JOIN of this stream with the global table, effectively doing a table lookup. (details)</p>
<p>The IGlobalKTable is fully bootstrapped upon (re)start of a KafkaStreams instance, which means the table is fully populated with all the data in the underlying topic that is available at the time of the startup. The actual data processing begins only once the bootstrapping has completed.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">GlobalTable</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table-store&quot;</span><span class="p">));</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(),</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is indirectly key-based, i.e. with the join predicate keymapper(leftRecord.key, leftRecord.value) == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.
Input records for the stream with a null key or a null value are ignored and do not trigger the join.
Input records for the table with a null value are interpreted as tombstones, which indicate the deletion of a record key from the table. Tombstones do not trigger the join.</p></li>
</ul>
</section>
<section id="id2">
<h3>Left Join<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKStream, IGlobalKTable) → IKStream</p></li>
</ul>
<p>Performs an LEFT JOIN of this stream with the global table, effectively doing a table lookup. (details)</p>
<p>The IGlobalKTable is fully bootstrapped upon (re)start of a KafkaStreams instance, which means the table is fully populated with all the data in the underlying topic that is available at the time of the startup. The actual data processing begins only once the bootstrapping has completed.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">stream1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Stream</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic1&quot;</span><span class="p">);</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">GlobalTable</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table-store&quot;</span><span class="p">));</span>

<span class="n">stream1</span><span class="p">.</span><span class="n">LeftJoin</span><span class="p">(</span><span class="n">table</span><span class="p">,</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">(),</span><span class="w"> </span>
<span class="w">                </span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">To</span><span class="p">(</span><span class="s">&quot;output-join&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is indirectly key-based, i.e. with the join predicate keymapper(leftRecord.key, leftRecord.value) == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Only input records for the left side (stream) trigger the join. Input records for the right side (table) update only the internal right-side join state.
Input records for the stream with a null key or a null value are ignored and do not trigger the join.
Input records for the table with a null value are interpreted as tombstones, which indicate the deletion of a record key from the table. Tombstones do not trigger the join.
For each input record on the left side that does not have any match on the right side, the joiner will be called with joiner(leftRecord.value, null)</p></li>
</ul>
</section>
</section>
<section id="iktable-iktable-equi-join">
<h2>IKTable-IKTable Equi-Join<a class="headerlink" href="#iktable-iktable-equi-join" title="Permalink to this heading">¶</a></h2>
<p>IKTable-IKTable equi-joins are always non-windowed joins. They are designed to be consistent with their counterparts in relational databases. The changelog streams of both IKTables are materialized into local state stores to represent the latest snapshot of their table duals. The join result is a new IKTable that represents the changelog stream of the join operation.</p>
<section id="id3">
<h3>Inner Join<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKTable, IKTable) → IKTable</p></li>
</ul>
<p>Performs an INNER JOIN of this table with another table. The result is an ever-updating KTable that represents the “current” result of the join.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table1-store&quot;</span><span class="p">));</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table2-store&quot;</span><span class="p">));</span>

<span class="kt">var</span><span class="w"> </span><span class="n">tableJoin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">table2</span><span class="p">,(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied value joiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key are ignored and do not trigger the join.</p></li>
<li><p>Input records with a null value are interpreted as tombstones for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join. When an input tombstone is received, then an output tombstone is forwarded directly to the join result IKTable if required (i.e. only if the corresponding key actually exists already in the join result IKTable).</p></li>
</ul>
</section>
<section id="id4">
<h3>Left Join<a class="headerlink" href="#id4" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKTable, IKTable) → IKTable</p></li>
</ul>
<p>Performs a LEFT JOIN of this table with another table.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table1-store&quot;</span><span class="p">));</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table2-store&quot;</span><span class="p">));</span>

<span class="kt">var</span><span class="w"> </span><span class="n">tableJoin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">LeftJoin</span><span class="p">(</span><span class="n">table2</span><span class="p">,(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied value joiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key are ignored and do not trigger the join.</p></li>
<li><p>Input records with a null value are interpreted as tombstones for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join. When an input tombstone is received, then an output tombstone is forwarded directly to the join result IKTable if required (i.e. only if the corresponding key actually exists already in the join result IKTable).</p></li>
<li><p>For each input record on the left side that does not have any match on the right side, the ValueJoiner will be called with (leftRecord.value, null); this explains the row with timestamp=3 in the table below, which lists [A, null] in the LEFT JOIN column.</p></li>
</ul>
</section>
<section id="outer-join">
<h3>Outer Join<a class="headerlink" href="#outer-join" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>(IKTable, IKTable) → IKTable</p></li>
</ul>
<p>Performs a OUTER JOIN of this table with another table.</p>
<p>Data must be co-partitioned: The input data for both sides must be co-partitioned.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">table1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table1-store&quot;</span><span class="p">));</span>
<span class="kt">var</span><span class="w"> </span><span class="n">table2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Table</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;topic2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">InMemory</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">.</span><span class="n">As</span><span class="p">(</span><span class="s">&quot;table2-store&quot;</span><span class="p">));</span>

<span class="kt">var</span><span class="w"> </span><span class="n">tableJoin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table1</span><span class="p">.</span><span class="n">OuterJoin</span><span class="p">(</span><span class="n">table2</span><span class="p">,(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">$&quot;{v1}-{v2}&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Detailed behavior:</p>
<ul class="simple">
<li><p>The join is key-based, i.e. with the join predicate leftRecord.key == rightRecord.key.</p></li>
<li><p>The join will be triggered under the conditions listed below whenever new input is received. When it is triggered, the user-supplied ValueJoiner will be called to produce join output records.</p></li>
<li><p>Input records with a null key are ignored and do not trigger the join.</p></li>
<li><p>Input records with a null value are interpreted as tombstones for the corresponding key, which indicate the deletion of the key from the table. Tombstones do not trigger the join. When an input tombstone is received, then an output tombstone is forwarded directly to the join result IKTable if required (i.e. only if the corresponding key actually exists already in the join result IKTable).</p></li>
<li><p>For each input record on one side that does not have any match on the other side, the ValueJoiner will be called with (leftRecord.value, null) or (null, rightRecord.value), respectively; this explains the rows with timestamp=3 and timestamp=7 in the table below, which list [A, null] and [null, b], respectively, in the OUTER JOIN column.</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="stateless-processors.html" class="btn btn-neutral float-left" title="Stateless processors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="stores.html" class="btn btn-neutral float-right" title="State stores" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, @LGouellec.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>